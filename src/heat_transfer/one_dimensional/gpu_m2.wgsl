const MAX_DELTA_TEMPERATURE: f32 = 10.0;
const MAX_TIME_SUBDIVISIONS: u32 = 4u;
const DELTA_TIME_GAS: f32 = 1.0;
const SIGMA: f32 = 0.0000000567; // 5.67*10e-8; 

const ADIABATIC_H: f32 = -100000.0;
const CONST_TEMP_H: f32 = -100001.0;

const DELTA_TIME_SOLID: f32 = 2.0;

//! cell_length
const CELL_LENGTH: u32 = 4u; const N = 2u;

//! cell_sizes
var<private> cell_sizes: array<f32, CELL_LENGTH> = array<f32, CELL_LENGTH>(0.0, 0.0, 0.0, 0.0);
//! cell_materials
var<private> cell_materials: array<u32, CELL_LENGTH> = array<u32, CELL_LENGTH>(0u, 0u, 0u, 0u);

var<workgroup> solve_matrix: array<vec4<f32>, N> = array<vec4<f32>, N>(); 

@group(0)
@binding(0)
var<storage, read_write> cell_temperatures: array<array<f32, CELL_LENGTH>>;


@group(1)
@binding(0)
var<storage, read_write> wall_heat_transfer_coefficients: array<vec2<f32>>;
@group(1)
@binding(1)
var<storage, read_write> wall_q_in: array<vec2<f32>>;

@group(1)
@binding(2)
var<uniform> delta_time: f32;


/// Autogenerated function to get the conductivity depending on material and temperature.
fn conductivity(id: u32, temperature: f32) -> f32 {
    //! conductivity
    // Fallback value.
    return 1.0;
}

/// Autogenerated function to get the specific_heat depending on material and temperature.
fn specific_heat(id: u32, temperature: f32) -> f32 {
    //! specific_heat
    // Fallback value.
    return 1.0;
}

/// Autogenerated function to get the density depending on material.
fn density(id: u32) -> f32 {
    //! density
    // Fallback value.
    return 1.0;
}

/// Autogenerated function to get the emissivity depending on material.
fn emissivity(id: u32) -> f32 {
    //! emissivity
    // Fallback value.
    return 1.0;
}



fn max_delta_temperature(index: u32, delta_time: f32) -> f32 {
    var delta_temperature = 0.0;

    let id_b = cell_materials[1];
    let t_b = cell_temperatures[index][1];
    let x_b = cell_sizes[1];
    let k_b = conductivity(id_b, t_b);

    let id_c = cell_materials[0];
    let t_c = cell_temperatures[index][0];
    var x_c = cell_sizes[0];
    let k_c = conductivity(id_c, t_c);
    let c_c = specific_heat(id_c, t_c);
    let rho_c = density(id_c);

    var k_m_b = (k_c + k_b) / 2.0;
    var before = k_m_b * (t_c - t_b) / ((x_c + x_b) / 2.0);

    var f1 = delta_time * (rho_c * c_c);
    // The virtual cells are ignored therefore the loop must be shorted on both ends by 1.
    for (var i = 1u; i < CELL_LENGTH - u32(1); i += 1u) {

        let id_a = cell_materials[i + 1u];
        let t_a = cell_temperatures[index][i + 1u];
        let x_a = cell_sizes[i];
        let k_a = conductivity(id_a, t_a);
        let c_a = specific_heat(id_a, t_a);
        let rho_a = density(id_a);


        let k_m_a = (k_c + k_a) / 2.0;

        let after = k_m_a * (t_a - t_c) / ((x_a + x_c) / 2.0);

        delta_temperature = max(abs(f1 * (after - before) / x_c), delta_temperature);

        x_c = x_a;
        before = after;
        f1 = delta_time * (rho_a * c_a);
    }

    return delta_temperature;
}

fn repeats(max_delta_temperature: f32) -> u32 {
    if max_delta_temperature < MAX_DELTA_TEMPERATURE {
        return 1u;
    }
    let eta = max_delta_temperature / MAX_DELTA_TEMPERATURE;
    let sub = clamp(u32(ceil(log(eta) / log(2.0))), 1u, MAX_TIME_SUBDIVISIONS);
    return sub;
}

fn calc_rfac2_and_qdxk_no_radiation(
    index: u32,
    wall_heat_transfer_coefficient: vec2<f32>,
    wall_q_in: vec2<f32>,
) -> vec4<f32> {
    let h_f = wall_heat_transfer_coefficient.x;
    var rfac2_f = 1.0;
    var qdxk_f = 0.0;
    if h_f == CONST_TEMP_H {
        let q2_f = wall_q_in.x;
        rfac2_f = -1.0;
        qdxk_f = 2.0 * q2_f;
    } else if h_f != ADIABATIC_H {
        let q2_f = wall_q_in.x;

        let temperature_f = (cell_temperatures[index][0] + cell_temperatures[index][1]) / 2.0;
        let material_id_f = cell_materials[0];
        let dx_f = cell_sizes[0];

        let emissivity_f = emissivity(material_id_f);
        let emission_rfac_f = 2.0 * emissivity_f * SIGMA * pow(temperature_f, 3.0);
        let emission_qdxk_f = 3.0 * emissivity_f * SIGMA * pow(temperature_f, 4.0);

        let rfac_f = 0.5 * h_f + emission_rfac_f;
        let k_f = conductivity(material_id_f, temperature_f);
        rfac2_f = (k_f / dx_f - rfac_f) / (k_f / dx_f + rfac_f);
        qdxk_f = (q2_f + emission_qdxk_f) / (k_f / dx_f + rfac_f);
    }

    let h_b = wall_heat_transfer_coefficient.y;
    var rfac2_b = 1.0;
    var qdxk_b = 0.0;
    if h_b == CONST_TEMP_H {
        let q2_b = wall_q_in.y;
        rfac2_b = -1.0;
        qdxk_b = 2.0 * q2_b;
    } else if h_b != ADIABATIC_H {
        let q2_b = wall_q_in.y;

        let temperature_b = (cell_temperatures[index][CELL_LENGTH - u32(1)] + cell_temperatures[index][CELL_LENGTH - u32(2)]) / 2.0;
        let material_id_b = cell_materials[CELL_LENGTH - u32(1)];
        let dx_b = cell_sizes[CELL_LENGTH - u32(1)];

        let emissivity_b = emissivity(material_id_b);
        let emission_rfac_b = 2.0 * emissivity_b * SIGMA * pow(temperature_b, 3.0);
        let emission_qdxk_b = 3.0 * emissivity_b * SIGMA * pow(temperature_b, 4.0);

        let rfac_b = 0.5 * h_b + emission_rfac_b;
        let k_b = conductivity(material_id_b, temperature_b);
        rfac2_b = (k_b / dx_b - rfac_b) / (k_b / dx_b + rfac_b);
        qdxk_b = (q2_b + emission_qdxk_b) / (k_b / dx_b + rfac_b);
    }


    return vec4<f32>(rfac2_f, qdxk_f, rfac2_b, qdxk_b);
}

fn populate_solve_matrix(index: u32, delta_time: f32) {
    var temperature_d = cell_temperatures[index][1];
    var material_id_d = cell_materials[1];
    var dx_d = cell_sizes[1];

    var f1 = 2.0 * density(material_id_d) * specific_heat(material_id_d, temperature_d);

    // B
    let temperature_b = cell_temperatures[index][0];
    let material_id_b = cell_materials[0];
    let dx_b = cell_sizes[0];

    let k_b = (conductivity(material_id_d, temperature_d) + conductivity(material_id_b, temperature_b)) / 2.0;
    var b = -delta_time * k_b / (f1 * dx_d * (dx_d + dx_b) / 2.0);
    var c_b = b * (temperature_d - temperature_b);

    for (var i = 1u; i < CELL_LENGTH - 1u; i += 1u) {
        // A
        let temperature_a = cell_temperatures[index][i + 1u];
        let material_id_a = cell_materials[i + 1u];
        let dx_a = cell_sizes[i + 1u];

        let k_a = (conductivity(material_id_d, temperature_d) + conductivity(material_id_a, temperature_a)) / 2.0;
        let a = -delta_time * k_a / (f1 * dx_d * (dx_d + dx_a) / 2.0);
        let c_a = a * (temperature_a - temperature_d);

        // D
        let d = 1.0 - a - b;

        // C
        let c = temperature_d - c_a + c_b;

        solve_matrix[i - 1u] = vec4<f32>(b, d, a, c);

        f1 = 2.0 * density(material_id_a) * specific_heat(material_id_a, temperature_a);
        let k_b = (conductivity(material_id_a, temperature_a) + conductivity(material_id_d, temperature_d)) / 2.0;
        b = -delta_time * k_b / (f1 * dx_a * (dx_a + dx_d) / 2.0);
        c_b = b * (temperature_a - temperature_d);

        temperature_d = temperature_a;
        material_id_d = material_id_a;
        dx_d = dx_a;
    }
}

fn solve_heat_transfer(index: u32, delta_time: f32, gas_interaction: vec4<f32>) {
    populate_solve_matrix(index, delta_time);


    solve_matrix[0][3] -= solve_matrix[0][0] * gas_interaction.y;
    solve_matrix[N - u32(1)][3] -= solve_matrix[N - u32(1)][2] * gas_interaction.w;

    solve_matrix[0][1] += solve_matrix[0][0] * gas_interaction.x;
    solve_matrix[N - u32(1)][1] += solve_matrix[N - u32(1)][2] * gas_interaction.z;

    for (var i = 1u; i < N; i += 1u) {
        let r = solve_matrix[i][0] / solve_matrix[i - u32(1)][1];
        solve_matrix[i][1] -= r * solve_matrix[i - u32(1)][2];
        solve_matrix[i][3] -= r * solve_matrix[i - u32(1)][3];
    }

    solve_matrix[N - u32(1)][3] /= solve_matrix[N - u32(1)][1];
    for (var i = N - u32(2); i > 0u; i -= u32(1)) {
        solve_matrix[i][3] = (solve_matrix[i][3] - solve_matrix[i][2] * solve_matrix[i + 1u][3]) / solve_matrix[i][1];
    }
    //HACK i >= 0u is not possible. probably because in the last iteration 0u - u32(1) is calculated, wich is not possible.
    solve_matrix[0][3] = (solve_matrix[0][3] - solve_matrix[0][2] * solve_matrix[1u][3]) / solve_matrix[0][1];

    for (var i = 0u; i < N; i += 1u) {
        cell_temperatures[index][i + 1u] = solve_matrix[i][3];
    }

    cell_temperatures[index][0] = cell_temperatures[index][1] * gas_interaction.x + gas_interaction.y;
    cell_temperatures[index][CELL_LENGTH - u32(1)] = cell_temperatures[index][CELL_LENGTH - u32(2)] * gas_interaction.z + gas_interaction.w;
}

fn heat_transfer(
    index: u32,
    delta_time: f32,
    wall_heat_transfer_coefficient: vec2<f32>,
    wall_q_in: vec2<f32>,
) {
    let max_delta_temperature = max_delta_temperature(index, delta_time);
    let repeats = repeats(max_delta_temperature);
    let new_delta_time = delta_time / f32(repeats);
    for (var i = 0u; i < repeats; i += 1u) {
        let gas_interaction = calc_rfac2_and_qdxk_no_radiation(
            index,
            wall_heat_transfer_coefficient,
            wall_q_in,
        );
        solve_heat_transfer(index, new_delta_time, gas_interaction);
    }
}


@compute
@workgroup_size(256)
fn compute(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index = global_id.x;
    if index >= arrayLength(&cell_temperatures) {
        return;
    }

    heat_transfer(index, delta_time, wall_heat_transfer_coefficients[index], wall_q_in[index]);
    wall_q_in[index].x = (cell_temperatures[index][0] + cell_temperatures[index][1]) / 2.0;
    wall_q_in[index].y = (cell_temperatures[index][CELL_LENGTH - u32(1)] + cell_temperatures[index][CELL_LENGTH - u32(2)]) / 2.0;
}