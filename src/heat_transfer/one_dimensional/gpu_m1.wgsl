const MAX_DELTA_TEMPERATURE: f32 = 10.0;
const MAX_TIME_SUBDIVISIONS: u32 = 4u;
const DELTA_TIME_GAS: f32 = 1.0;
const SIGMA: f32 = 0.0000000567; // 5.67*10e-8; 

const DELTA_TIME_SOLID: f32 = 2.0;

const ADIABATIC_H: f32 = -100000.0;
const CONST_TEMP_H: f32 = -100001.0;

struct WallCell {
    size: f32,
    material: u32,
    temperature: f32,
}

@group(0)
@binding(0)
var<storage> cell_indices: array<u32>;
@group(0)
@binding(1)
var<storage, read_write> wall_cells: array<WallCell>;

@group(1)
@binding(0)
var <storage, read_write> solve_matrix_b: array<f32>;
@group(1)
@binding(1)
var <storage, read_write> solve_matrix_d: array<f32>;
@group(1)
@binding(2)
var <storage, read_write> solve_matrix_a: array<f32>;
@group(1)
@binding(3)
var <storage, read_write> solve_matrix_c: array<f32>;

@group(2)
@binding(0)
var<storage, read_write> wall_heat_transfer_coefficients: array<vec2<f32>>;

@group(2)
@binding(1)
var<storage, read_write> wall_q_in: array<vec2<f32>>;

@group(2)
@binding(2)
var<uniform> delta_time: f32;


/// Autogenerated function to get the conductivity depending on material and temperature.
fn conductivity(id: u32, temperature: f32) -> f32 {
    //! conductivity
    // Fallback value.
    return 1.0;
}

/// Autogenerated function to get the specific_heat depending on material and temperature.
fn specific_heat(id: u32, temperature: f32) -> f32 {
    //! specific_heat
    // Fallback value.
    return 1.0;
}

/// Autogenerated function to get the density depending on material.
fn density(id: u32) -> f32 {
    //! density
    // Fallback value.
    return 1.0;
}

/// Autogenerated function to get the emissivity depending on material.
fn emissivity(id: u32) -> f32 {
    //! emissivity
    // Fallback value.
    return 1.0;
}

fn max_delta_temperature(start: u32, end: u32, delta_time: f32) -> f32 {
    var delta_temperature = 0.0;

    let cell_b = wall_cells[start];
    let id_b = cell_b.material;
    let t_b = cell_b.temperature;
    let x_b = cell_b.size;
    let k_b = conductivity(id_b, t_b);

    let cell_c = wall_cells[start];
    let id_c = cell_c.material;
    let t_c = cell_c.temperature;
    var x_c = cell_c.size;
    let k_c = conductivity(id_c, t_c);
    let c_c = specific_heat(id_c, t_c);
    let rho_c = density(id_c);

    let k_m_b = (k_c + k_b) / 2.0;
    var before = k_m_b * (t_c - t_b) / ((x_c + x_b) / 2.0);

    var f1 = delta_time * (rho_c * c_c);
    for (var i = start + 1u; i < end - 2u; i += 1u) {

        let cell_a = wall_cells[i + 1u];
        let id_a = cell_a.material;
        let t_a = cell_a.temperature;
        let x_a = cell_a.size;
        let k_a = conductivity(id_a, t_a);
        let c_a = specific_heat(id_a, t_a);
        let rho_a = density(id_a);

        let k_m_a = (k_c + k_a) / 2.0;

        let after = k_m_a * (t_a - t_c) / ((x_a + x_c) / 2.0);

        delta_temperature = max(abs(f1 * (after - before) / x_c), delta_temperature);

        x_c = x_a;
        before = after;
        f1 = delta_time * (rho_a * c_a);
    }

    return delta_temperature;
}

fn repeats(max_delta_temperature: f32) -> u32 {
    if max_delta_temperature < MAX_DELTA_TEMPERATURE {
        return 1u;
    }
    let eta = max_delta_temperature / MAX_DELTA_TEMPERATURE;
    let sub = clamp(u32(ceil(log(eta) / log(2.0))), 1u, MAX_TIME_SUBDIVISIONS);
    return sub;
}

fn calc_rfac2_and_qdxk_no_radiation(
    start: u32,
    end: u32,
    wall_heat_transfer_coefficient: vec2<f32>,
    wall_q_in: vec2<f32>,
) -> vec4<f32> {
    let h_f = wall_heat_transfer_coefficient.x;
    var rfac2_f = 1.0;
    var qdxk_f = 0.0;
    if h_f == CONST_TEMP_H {
        let q2_f = wall_q_in.x;
        rfac2_f = -1.0;
        qdxk_f = 2.0 * q2_f;
    } else if h_f != ADIABATIC_H {
        let q2_f = wall_q_in.x;

        let cell_v = wall_cells[start];
        let cell_temperature_f = wall_cells[start + 1u].temperature;
        let temperature_f = (cell_v.temperature + cell_temperature_f) / 2.0;
        let material_id_f = cell_v.material;
        let dx_f = cell_v.size;

        let emissivity_f = emissivity(material_id_f);
        let emission_rfac_f = 2.0 * emissivity_f * SIGMA * pow(temperature_f, 3.0);
        let emission_qdxk_f = 3.0 * emissivity_f * SIGMA * pow(temperature_f, 4.0);

        let rfac_f = 0.5 * h_f + emission_rfac_f;
        let k_f = conductivity(material_id_f, temperature_f);
        rfac2_f = (k_f / dx_f - rfac_f) / (k_f / dx_f + rfac_f);
        qdxk_f = (q2_f + emission_qdxk_f) / (k_f / dx_f + rfac_f);
    }

    let h_b = wall_heat_transfer_coefficient.y;
    var rfac2_b = 1.0;
    var qdxk_b = 0.0;
    if h_b == CONST_TEMP_H {
        let q2_b = wall_q_in.y;
        rfac2_b = -1.0;
        qdxk_b = 2.0 * q2_b;
    } else if h_b != ADIABATIC_H {
        let q2_b = wall_q_in.y;

        let cell_v = wall_cells[end - 1u];
        let cell_temperature_b = wall_cells[end - 2u].temperature;

        let temperature_b = (cell_v.temperature + cell_temperature_b) / 2.0;
        let material_id_b = cell_v.material;
        let dx_b = cell_v.size;

        let emissivity_b = emissivity(material_id_b);
        let emission_rfac_b = 2.0 * emissivity_b * SIGMA * pow(temperature_b, 3.0);
        let emission_qdxk_b = 3.0 * emissivity_b * SIGMA * pow(temperature_b, 4.0);

        let rfac_b = 0.5 * h_b + emission_rfac_b;
        let k_b = conductivity(material_id_b, temperature_b);
        rfac2_b = (k_b / dx_b - rfac_b) / (k_b / dx_b + rfac_b);
        qdxk_b = (q2_b + emission_qdxk_b) / (k_b / dx_b + rfac_b);
    }

    return vec4<f32>(rfac2_f, qdxk_f, rfac2_b, qdxk_b);
}

fn populate_solve_matrix(start: u32, end: u32, delta_time: f32) {

    let cell_d = wall_cells[start + 1u];
    var temperature_d = cell_d.temperature;
    var material_id_d = cell_d.material;
    var dx_d = cell_d.size;

    var f1 = 2.0 * density(material_id_d) * specific_heat(material_id_d, temperature_d);

    // B
    let cell_b = wall_cells[start];
    let temperature_b = cell_b.temperature;
    let material_id_b = cell_b.material;
    let dx_b = cell_b.size;

    let k_b = (conductivity(material_id_d, temperature_d) + conductivity(material_id_b, temperature_b)) / 2.0;
    var b = -delta_time * k_b / (f1 * dx_d * (dx_d + dx_b) / 2.0);
    var c_b = b * (temperature_d - temperature_b);

    for (var i = start + 1u; i < end - 1u; i += 1u) {

        // A
        let cell_a = wall_cells[i + 1u];
        let temperature_a = cell_a.temperature;
        let material_id_a = cell_a.material;
        let dx_a = cell_a.size;

        let k_a = (conductivity(material_id_d, temperature_d) + conductivity(material_id_a, temperature_a)) / 2.0;
        let a = -delta_time * k_a / (f1 * dx_d * (dx_d + dx_a) / 2.0);
        let c_a = a * (temperature_a - temperature_d);

        // D
        let d = 1.0 - a - b;

        // C
        let c = temperature_d - c_a + c_b;

        solve_matrix_b[i] = b;
        solve_matrix_d[i] = d;
        solve_matrix_a[i] = a;
        solve_matrix_c[i] = c;

        f1 = 2.0 * density(material_id_a) * specific_heat(material_id_a, temperature_a);
        let k_b = (conductivity(material_id_a, temperature_a) + conductivity(material_id_d, temperature_d)) / 2.0;
        b = -delta_time * k_b / (f1 * dx_a * (dx_a + dx_d) / 2.0);
        c_b = b * (temperature_a - temperature_d);

        temperature_d = temperature_a;
        material_id_d = material_id_a;
        dx_d = dx_a;
    }
}

fn solve_heat_transfer(start: u32, end: u32, delta_time: f32, gas_interaction: vec4<f32>) {

    populate_solve_matrix(start, end, delta_time);

    // x = b, y = d, z = a, w = c
    solve_matrix_c[start + 1u] -= solve_matrix_b[start + 1u] * gas_interaction.y; 
    solve_matrix_c[end - 2u] -= solve_matrix_a[end - 2u] * gas_interaction.w; 

    solve_matrix_d[start + 1u] += solve_matrix_b[start + 1u] * gas_interaction.x; 
    solve_matrix_d[end - 2u] += solve_matrix_a[end - 2u] * gas_interaction.z; 

    for (var i = start + 2u; i < end - 1u; i += 1u) {
        let r = solve_matrix_b[i] / solve_matrix_d[i - 1u];
        solve_matrix_d[i] -= r * solve_matrix_a[i - 1u];
        solve_matrix_c[i] -= r * solve_matrix_c[i - 1u];
    }

    solve_matrix_c[end - 2u] /= solve_matrix_d[end - 2u];
    for (var i = end - 3u; i >= start + 1u; i -= 1u) {
        solve_matrix_c[i] = (solve_matrix_c[i] - solve_matrix_a[i] * solve_matrix_c[i + 1u]) / solve_matrix_d[i];
    }

    for (var i = start + 1u; i < end - 1u; i += 1u) {
        wall_cells[i].temperature = solve_matrix_c[i];
    }

    wall_cells[start].temperature = wall_cells[start + 1u].temperature * gas_interaction.x + gas_interaction.y;
    wall_cells[end - 1u].temperature = wall_cells[end - 2u].temperature * gas_interaction.z + gas_interaction.w;
}

fn heat_transfer(
    start: u32,
    end: u32,
    delta_time: f32,
    wall_heat_transfer_coefficient: vec2<f32>,
    wall_q_in: vec2<f32>,
) {
    let max_delta_temperature = max_delta_temperature(start, end, delta_time); 
    let repeats = repeats(max_delta_temperature); 

    let new_delta_time = delta_time / f32(repeats); 
    for (var i = 0u; i < repeats; i += 1u) {
        let gas_interaction = calc_rfac2_and_qdxk_no_radiation(
            start,
            end,
            wall_heat_transfer_coefficient,
            wall_q_in,
        );
        solve_heat_transfer(start, end, new_delta_time, gas_interaction);
    }
}




@compute
@workgroup_size(256)
fn compute(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index = global_id.x;
    if index >= arrayLength(&cell_indices) {
        return;
    }
    let end = cell_indices[index];
    var start = 0u;
    if index > 0u {
        start = cell_indices[index - 1u];
    }

    heat_transfer(start, end, delta_time, wall_heat_transfer_coefficients[index], wall_q_in[index]);

    wall_q_in[index].x = (wall_cells[start].temperature + wall_cells[start + 1u].temperature) / 2.0;
    wall_q_in[index].y = (wall_cells[end - 1u].temperature + wall_cells[end - 2u].temperature) / 2.0;
}